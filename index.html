<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Satoshi World | Panel Cyberpunk</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #05070c;
        --panel: rgba(12, 18, 32, 0.92);
        --panel-border: rgba(88, 247, 255, 0.4);
        --neon: #4ef2ff;
        --neon-2: #b44bff;
        --accent: #f7ff6d;
        --text: #e3f3ff;
        --muted: #9aa9bf;
        --danger: #ff6b88;
        --success: #37f6b2;
        --shadow: 0 0 20px rgba(78, 242, 255, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Rajdhani", "Orbitron", "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(circle at top, rgba(88, 247, 255, 0.15), transparent 55%),
          linear-gradient(140deg, #04060c, #0b0f1d 60%, #090a14);
        color: var(--text);
        min-height: 100vh;
      }

      .app {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 28px 5vw 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .brand h1 {
        margin: 0;
        font-size: clamp(1.6rem, 3vw, 2.4rem);
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      .brand span {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .mode-toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 0.95rem;
      }

      .header-actions {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: flex-end;
      }

      .header-actions button {
        width: auto;
        padding: 10px 16px;
      }

      .switch {
        position: relative;
        width: 52px;
        height: 26px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 999px;
        border: 1px solid var(--panel-border);
        box-shadow: var(--shadow);
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: var(--neon);
        border-radius: 50%;
        transition: transform 0.2s ease;
      }

      .switch input:checked + .slider {
        transform: translateX(26px);
        background: var(--accent);
      }

      main {
        flex: 1;
        padding: 20px 5vw 40px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .layout {
        display: grid;
        gap: 20px;
        grid-template-columns: minmax(180px, 220px) minmax(0, 1fr) minmax(180px, 220px);
        align-items: start;
      }

      .side-tabs {
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: sticky;
        top: 20px;
      }

      .side-tabs .panel {
        padding: 16px;
      }

      .tab-list {
        display: grid;
        gap: 8px;
      }

      .tab-button {
        width: 100%;
        text-align: left;
        border-radius: 10px;
        padding: 10px 12px;
        background: rgba(8, 12, 22, 0.8);
        color: var(--text);
        border: 1px solid transparent;
        font-size: 0.95rem;
        cursor: pointer;
      }

      .tab-button.active {
        border-color: rgba(78, 242, 255, 0.5);
        box-shadow: var(--shadow);
        background: rgba(78, 242, 255, 0.12);
      }

      .tab-content {
        display: none;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .tab-content.active {
        display: grid;
      }

      .tab-content h3 {
        margin: 0;
        color: var(--text);
        font-size: 1rem;
      }

      .status-message {
        margin: 8px 0 0;
        font-size: 0.85rem;
        min-height: 1.2em;
      }

      .status-message.is-loading {
        color: var(--accent);
      }

      .status-message.is-success {
        color: var(--success);
      }

      .status-message.is-error {
        color: var(--danger);
      }

      .terminal {
        font-family: "Share Tech Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 0.85rem;
        background: rgba(5, 9, 18, 0.9);
        border-radius: 12px;
        padding: 14px;
        border: 1px solid rgba(78, 242, 255, 0.2);
        color: #a6ffdf;
        height: 240px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .terminal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.8rem;
        color: var(--muted);
      }

      .terminal-log {
        display: grid;
        gap: 6px;
        overflow: hidden;
        flex: 1;
      }

      .terminal-line {
        display: flex;
        gap: 8px;
      }

      .terminal-line span {
        color: #d3fff2;
      }

      .grid {
        display: grid;
        gap: 20px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        padding: 20px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(6px);
      }

      .panel h2 {
        margin-top: 0;
        font-size: 1.2rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(78, 242, 255, 0.1);
      }

      .stat-row:last-child {
        border-bottom: none;
      }

      .stat-label {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .stat-value {
        font-weight: 600;
      }

      .actions {
        display: grid;
        gap: 12px;
      }

      label {
        font-size: 0.9rem;
        color: var(--muted);
        margin-bottom: 6px;
        display: block;
      }

      input,
      select,
      textarea {
        width: 100%;
        background: rgba(8, 12, 22, 0.9);
        border: 1px solid rgba(78, 242, 255, 0.3);
        border-radius: 10px;
        padding: 10px 12px;
        color: var(--text);
        font-size: 1rem;
      }

      button {
        width: 100%;
        border: none;
        border-radius: 10px;
        padding: 12px 16px;
        background: linear-gradient(120deg, var(--neon), var(--neon-2));
        color: #0a0e1a;
        font-size: 1rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        text-transform: uppercase;
      }

      button.secondary {
        background: linear-gradient(120deg, rgba(78, 242, 255, 0.2), rgba(180, 75, 255, 0.35));
        color: var(--text);
      }

      .status-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 12px;
      }

      .tag {
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(78, 242, 255, 0.12);
        border: 1px solid rgba(78, 242, 255, 0.35);
        font-size: 0.8rem;
      }

      .tag.success {
        border-color: rgba(55, 246, 178, 0.5);
        color: var(--success);
      }

      .tag.warn {
        border-color: rgba(255, 107, 136, 0.5);
        color: var(--danger);
      }

      .advanced {
        display: none;
      }

      #mode-toggle:checked ~ main .advanced {
        display: block;
      }

      .advanced-block {
        display: none;
      }

      #mode-toggle:checked ~ main .advanced-block {
        display: block;
      }

      #mode-toggle:checked ~ main .advanced-panel {
        border-color: rgba(247, 255, 109, 0.6);
      }

      .footer-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .footer-actions button {
        flex: 1 1 160px;
      }

      .helper-text {
        color: var(--muted);
        font-size: 0.85rem;
        margin-top: 8px;
      }

      .helper-text.warn {
        color: var(--danger);
      }

      .feedback {
        margin: 0;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(78, 242, 255, 0.35);
        background: rgba(78, 242, 255, 0.08);
        color: var(--text);
        font-size: 0.9rem;
      }

      .feedback.success {
        border-color: rgba(55, 246, 178, 0.5);
        color: var(--success);
      }

      .feedback.warn {
        border-color: rgba(255, 107, 136, 0.5);
        color: var(--danger);
      }

      .callout {
        background: rgba(78, 242, 255, 0.08);
        border: 1px solid rgba(78, 242, 255, 0.3);
        border-radius: 12px;
        padding: 14px 16px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .callout strong {
        color: var(--text);
      }

      .inline-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .inline-actions button {
        flex: 1 1 160px;
      }

      .wallet-status {
        display: grid;
        gap: 6px;
        font-size: 0.95rem;
      }

      .wallet-status span {
        color: var(--muted);
      }

      .list {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }

      .list-item {
        border: 1px solid rgba(78, 242, 255, 0.2);
        border-radius: 12px;
        padding: 12px;
        background: rgba(6, 10, 20, 0.6);
      }

      .list-item h3 {
        margin: 0 0 6px;
        font-size: 1rem;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.8rem;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(55, 246, 178, 0.5);
        color: var(--success);
      }

      .status-pill.warn {
        border-color: rgba(255, 107, 136, 0.5);
        color: var(--danger);
      }

      .status-pill.neutral {
        border-color: rgba(78, 242, 255, 0.4);
        color: var(--neon);
      }

      .divider {
        height: 1px;
        width: 100%;
        background: rgba(78, 242, 255, 0.12);
        margin: 12px 0;
      }

      @media (max-width: 720px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }

        .mode-toggle {
          width: 100%;
          justify-content: space-between;
        }

        .layout {
          grid-template-columns: 1fr;
        }

        .side-tabs {
          position: static;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="brand">
          <h1>Satoshi World</h1>
          <span>Panel de control • Ciudad cibernética</span>
        </div>
        <div class="mode-toggle">
          <span>Modo básico</span>
          <label class="switch" for="mode-toggle" aria-label="Alternar modo avanzado">
            <input id="mode-toggle" type="checkbox" />
            <span class="slider"></span>
          </label>
          <span>Modo avanzado</span>
        </div>
        <div class="header-actions">
          <button type="button" class="secondary" id="fullscreen-toggle" aria-pressed="false">
            Entrar en modo pantalla completa
          </button>
          <span class="status-pill neutral" id="fullscreen-status">Pantalla completa: inactiva</span>
        </div>
      </header>

      <main>
        <section class="layout">
          <aside class="side-tabs" aria-label="Pestañas laterales">
            <div class="panel">
              <h2>White paper</h2>
              <div class="tab-list" role="tablist" aria-label="Secciones informativas">
                <button class="tab-button active" type="button" role="tab" aria-selected="true" data-tab="whitepaper">
                  White paper
                </button>
                <button class="tab-button" type="button" role="tab" aria-selected="false" data-tab="citymap">
                  Mapa de ciudad
                </button>
                <button class="tab-button" type="button" role="tab" aria-selected="false" data-tab="economy">
                  Economía circular
                </button>
                <button class="tab-button" type="button" role="tab" aria-selected="false" data-tab="community">
                  Comunidad
                </button>
              </div>
            </div>
            <div class="panel">
              <div class="tab-content active" id="tab-whitepaper" role="tabpanel">
                <h3>Funciones clave</h3>
                <p>
                  1) Panel de control con wallet Web3. 2) Registro de bots y tareas en tiempo real. 3) Laboratorio de
                  proyectos con scripts verificables. 4) Orquestación de pagos y reputación en cadena. 5) Panel de
                  seguridad con auditorías automáticas.
                </p>
                <p>
                  La visión es conectar infraestructura urbana, datos abiertos y capital comunitario. Los módulos
                  crecen por capas: básico (control), coordinación (bots), expansión (mercado).
                </p>
              </div>
              <div class="tab-content" id="tab-citymap" role="tabpanel">
                <h3>Mapa vivo</h3>
                <p>Sector 01: energía solar • Sector 02: reciclaje • Sector 03: movilidad autónoma • Sector 04: agua limpia.</p>
                <p>Integración futura: mapas 3D, alertas y rutas de misión por barrio.</p>
              </div>
              <div class="tab-content" id="tab-economy" role="tabpanel">
                <h3>Economía circular</h3>
                <p>Tokens por impacto real, incentivos a reciclaje, puntos por mantenimiento y reputación pública.</p>
                <p>Modelo híbrido: donaciones, microservicios y financiación distribuida.</p>
              </div>
              <div class="tab-content" id="tab-community" role="tabpanel">
                <h3>Comunidad</h3>
                <p>Gobernanza abierta, votaciones locales, prioridades de misión y votación por barrios.</p>
                <p>Un hub para ciudadanía, ONGs y empresas con herramientas compartidas.</p>
              </div>
            </div>
          </aside>

          <div class="content">
            <section class="panel" aria-labelledby="mission-title">
              <h2 id="mission-title">Ciudad viva: 10K bots + personas</h2>
              <p class="callout">
                <strong>Objetivo:</strong> todo lo que ves en la web debe conectarse a infraestructura real. Esta versión
                ya permite operar con wallet Web3, registrar proyectos y coordinar bots desde la interfaz. Puedes
                enlazar tu API de producción para que funcione como panel completo.
              </p>
              <div class="grid">
                <div>
                  <label for="api-base">API base (opcional)</label>
                  <input id="api-base" type="url" placeholder="https://api.tuciudad.com" aria-label="API base" />
                  <p class="helper-text">Si defines una API, las acciones se enviarán a producción automáticamente.</p>
                </div>
                <div class="wallet-status" aria-live="polite">
                  <strong>Estado de infraestructura</strong>
                  <div><span>API:</span> <span id="api-status">Sin configurar</span></div>
                  <div><span>Wallet:</span> <span id="wallet-status">No conectada</span></div>
                  <div><span>Red:</span> <span id="network-status">Desconocida</span></div>
                </div>
              </div>
            </section>

            <section class="panel" aria-labelledby="feedback-title">
              <h2 id="feedback-title">Centro de alertas</h2>
              <p class="feedback" id="action-feedback" aria-live="polite">Sin eventos recientes.</p>
            </section>

            <section class="grid">
              <article class="panel" aria-labelledby="balance-title">
                <h2 id="balance-title">Balance</h2>
                <div class="stat-row">
                  <span class="stat-label">Saldo total</span>
                  <span class="stat-value" id="metric-total-balance">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Disponible</span>
                  <span class="stat-value" id="metric-available-balance">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Bloqueado</span>
                  <span class="stat-value" id="metric-locked-balance">—</span>
                </div>
                <div class="status-tags">
                  <span class="tag success">Bóveda cifrada</span>
                  <span class="tag">Optimización activa</span>
                  <span class="tag warn">2 alertas</span>
                </div>
              </article>

              <article class="panel" aria-labelledby="send-title">
                <h2 id="send-title">Enviar / Recibir</h2>
                <div class="actions">
                  <button type="button" class="secondary" data-action="connect-wallet" aria-label="Conectar wallet Web3">
                    Conectar wallet Web3
                  </button>
                  <div>
                    <label for="send-to">Dirección destino</label>
                    <input id="send-to" type="text" placeholder="sat://wallet/0x..." aria-label="Dirección destino" />
                  </div>
                  <div>
                    <label for="send-amount">Cantidad</label>
                    <input id="send-amount" type="number" placeholder="0.00" aria-label="Cantidad a enviar" />
                  </div>
                  <button type="button" data-action="send" aria-label="Enviar fondos">Enviar fondos</button>
                  <button type="button" class="secondary" data-action="receive" aria-label="Generar QR de recepción">
                    Generar QR de recepción
                  </button>
                  <p class="status-message" id="send-status" aria-live="polite"></p>
                </div>
              </article>

              <article class="panel" aria-labelledby="activity-title">
                <h2 id="activity-title">Actividad</h2>
                <div class="stat-row">
                  <span class="stat-label">Última transacción</span>
                  <span class="stat-value" id="last-transaction">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Operaciones pendientes</span>
                  <span class="stat-value" id="pending-ops">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Agentes activos</span>
                  <span class="stat-value" id="metric-active-agents">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Nodo preferido</span>
                  <span class="stat-value" id="metric-preferred-node">—</span>
                </div>
                <button
                  type="button"
                  class="secondary"
                  data-action="activity"
                  data-requires-api="true"
                  aria-label="Ver actividad completa"
                >
                  Ver actividad completa
                </button>
                <p class="status-message" id="activity-status" aria-live="polite"></p>
              </article>
            </section>

            <section class="grid">
              <article class="panel" aria-labelledby="bots-title">
                <h2 id="bots-title">Bots en acción</h2>
                <div class="actions">
                  <div>
                    <label for="bot-task">Tarea del bot</label>
                    <input id="bot-task" type="text" placeholder="Ej: limpiar avenida, reparar luminaria" />
                  </div>
                  <div>
                    <label for="bot-budget">Presupuesto (₿)</label>
                    <input id="bot-budget" type="number" min="0" step="0.01" placeholder="0.00" />
                  </div>
                  <button type="button" data-action="deploy-bot" data-requires-api="true">Desplegar bot</button>
                  <button type="button" class="secondary" data-action="toggle-autopay" data-requires-api="true">
                    Auto-pago coordinado
                  </button>
                  <p class="helper-text" id="autopay-status">Auto-pago: apagado</p>
                  <p class="status-message" id="bot-status" aria-live="polite"></p>
                </div>
                <div class="divider"></div>
                <div class="list" id="bot-list" aria-live="polite"></div>
              </article>

              <article class="panel" aria-labelledby="terminal-title">
                <h2 id="terminal-title">Terminal de 10K bots</h2>
                <div class="terminal" aria-live="polite">
                  <div class="terminal-header">
                    <span>Simulación de aprendizaje: 10.000 bots entrenando</span>
                    <span id="terminal-clock">00:00:00</span>
                  </div>
                  <div class="terminal-log" id="terminal-log"></div>
                </div>
                <p class="helper-text">
                  Vista simplificada del aprendizaje colectivo, mejoras de modelos y progreso del ecosistema. Cambia al modo
                  avanzado para más detalles.
                </p>
              </article>
            </section>

            <section class="grid advanced-block">
              <article class="panel" aria-labelledby="network-title">
                <h2 id="network-title">Estado de red</h2>
                <div class="stat-row">
                  <span class="stat-label">Latencia</span>
                  <span class="stat-value" id="metric-network-latency">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Peers activos</span>
                  <span class="stat-value" id="metric-network-peers">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Ancho de banda</span>
                  <span class="stat-value" id="metric-network-bandwidth">—</span>
                </div>
                <button
                  type="button"
                  class="secondary"
                  data-action="sync"
                  data-requires-api="true"
                  aria-label="Sincronizar red"
                >
                  Sincronizar red
                </button>
              </article>

              <article class="panel" aria-labelledby="sync-title">
                <h2 id="sync-title">Sincronización</h2>
                <div class="stat-row">
                  <span class="stat-label">Altura de bloque</span>
                  <span class="stat-value" id="metric-sync-height">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Progreso</span>
                  <span class="stat-value" id="metric-sync-progress">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Tiempo estimado</span>
                  <span class="stat-value" id="metric-sync-eta">—</span>
                </div>
                <div class="status-tags">
                  <span class="tag success">Canal cuántico estable</span>
                  <span class="tag">Turbo sync</span>
                </div>
              </article>

              <article class="panel" aria-labelledby="security-title">
                <h2 id="security-title">Seguridad</h2>
                <div class="stat-row">
                  <span class="stat-label">Copia de seguridad</span>
                  <span class="stat-value">Actualizada hoy</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Seed</span>
                  <span class="stat-value">Vault 2/3</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Firewall</span>
                  <span class="stat-value">Activo</span>
                </div>
                <button type="button" class="secondary" data-action="backup" aria-label="Gestionar copias de seguridad">
                  Gestionar copias de seguridad
                </button>
              </article>
            </section>

            <section class="grid advanced-block">
              <article class="panel" aria-labelledby="mining-title">
                <h2 id="mining-title">Minería / Quantum</h2>
                <div class="stat-row">
                  <span class="stat-label">Rendimiento</span>
                  <span class="stat-value" id="metric-mining-performance">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Núcleos activos</span>
                  <span class="stat-value" id="metric-mining-cores">—</span>
                </div>
                <div class="stat-row">
                  <span class="stat-label">Eficiencia</span>
                  <span class="stat-value" id="metric-mining-efficiency">—</span>
                </div>
                <div class="actions">
                  <button type="button" data-action="mine" data-requires-api="true" aria-label="Iniciar minería cuántica">
                    Iniciar minería cuántica
                  </button>
                  <button
                    type="button"
                    class="secondary"
                    data-action="optimize"
                    data-requires-api="true"
                    aria-label="Optimizar minería"
                  >
                    Optimizar nodos
                  </button>
                </div>
              </article>

              <article class="panel advanced advanced-panel" aria-labelledby="advanced-title">
                <h2 id="advanced-title">Configuración avanzada</h2>
                <div class="actions">
                  <div>
                    <label for="routing">Ruteo multicanal</label>
                    <select id="routing" aria-label="Ruteo multicanal">
                      <option>Auto</option>
                      <option>Canal 7</option>
                      <option>Canal 12</option>
                      <option>Canal 21</option>
                    </select>
                  </div>
                  <div>
                    <label for="quantum">Algoritmo cuántico</label>
                    <select id="quantum" aria-label="Algoritmo cuántico">
                      <option>Q-Flux</option>
                      <option>Neutrino Pulse</option>
                      <option>Photon Forge</option>
                    </select>
                  </div>
                  <div>
                    <label for="threshold">Umbral de confirmación</label>
                    <input id="threshold" type="number" placeholder="6" aria-label="Umbral de confirmación" />
                  </div>
                  <button
                    type="button"
                    class="secondary"
                    data-action="save-settings"
                    data-requires-api="true"
                    aria-label="Guardar configuración avanzada"
                  >
                    Guardar configuración
                  </button>
                  <p class="helper-text">Panel avanzado oculto por defecto. Activa el modo avanzado para editar.</p>
                </div>
              </article>
            </section>

            <section class="grid advanced-block">
              <article class="panel" aria-labelledby="projects-title">
                <h2 id="projects-title">Programar y subir proyectos</h2>
                <div class="actions">
                  <div>
                    <label for="project-name">Nombre del proyecto</label>
                    <input id="project-name" type="text" placeholder="Ej: Jardín solar comunitario" />
                  </div>
                  <div>
                    <label for="project-desc">Descripción técnica</label>
                    <textarea id="project-desc" rows="3" placeholder="Describe cómo mejora la ciudad..."></textarea>
                  </div>
                  <div>
                    <label for="project-code">Código / Script</label>
                    <textarea id="project-code" rows="4" placeholder="// pega tu código aquí"></textarea>
                  </div>
 
                  <button type="button" data-action="publish-project">Publicar proyecto</button>
                  <p class="status-message" id="project-status" aria-live="polite"></p>

                  <button type="button" data-action="publish-project" data-requires-api="true">Publicar proyecto</button>
 
                </div>
                <div class="divider"></div>
                <div class="list" id="project-list" aria-live="polite"></div>
              </article>

              <article class="panel" aria-labelledby="advanced-security-title">
                <h2 id="advanced-security-title">Configuración avanzada de seguridad</h2>
                <div class="grid">
                  <div>
                    <label for="seed-notes">Notas de seed</label>
                    <textarea id="seed-notes" rows="3" placeholder="Registro cifrado..." aria-label="Notas de seed"></textarea>
                  </div>
                  <div>
                    <label for="cold-storage">Cold storage</label>
                    <select id="cold-storage" aria-label="Estado de cold storage">
                      <option>Desconectado</option>
                      <option>Verificado</option>
                      <option>En bóveda física</option>
                    </select>
                    <p class="helper-text">Mantén al menos un backup fuera de línea.</p>
                  </div>
                </div>
                <div class="footer-actions">
                  <button
                    type="button"
                    class="secondary"
                    data-action="export"
                    data-requires-api="true"
                    aria-label="Exportar configuración"
                  >
                    Exportar configuración
                  </button>
                  <button type="button" data-action="lockdown" data-requires-api="true" aria-label="Activar lockdown">
                    Activar lockdown
                  </button>
                </div>
                <p class="helper-text" id="lockdown-status">Lockdown: inactivo</p>
              </article>
            </section>
          </div>

          <aside class="side-tabs" aria-label="Pestañas de apoyo">
            <div class="panel">
              <h2>Centro táctico</h2>
              <div class="status-tags">
                <span class="tag success">10K bots</span>
                <span class="tag">24 distritos</span>
                <span class="tag warn">2 alertas</span>
              </div>
              <div class="divider"></div>
              <div class="list">
                <div class="list-item">
                  <h3>Prioridades hoy</h3>
                  <p class="helper-text">Iluminación • Limpieza • Seguridad nocturna.</p>
                </div>
                <div class="list-item">
                  <h3>Checklist rápido</h3>
                  <p class="helper-text">✔️ Conecta wallet • ✔️ Define API • ✔️ Lanza misión.</p>
                </div>
                <div class="list-item">
                  <h3>Radar comunitario</h3>
                  <p class="helper-text">5 barrios votando misiones nuevas.</p>
                </div>
              </div>
            </div>
            <div class="panel">
              <h2>Atajos</h2>
              <div class="inline-actions">
                <button type="button" class="secondary" data-action="deploy-bot" data-requires-api="true">Nueva misión</button>
                <button type="button" class="secondary" data-action="publish-project" data-requires-api="true">Publicar idea</button>
              </div>
            </div>
          </aside>
        </section>
      </main>
    </div>
    <script>
      const storage = {
        get(key, fallback) {
          try {
            const raw = localStorage.getItem(key);
            return raw ? JSON.parse(raw) : fallback;
          } catch (error) {
            return fallback;
          }
        },
        set(key, value) {
          localStorage.setItem(key, JSON.stringify(value));
        },
      };

      const state = {
        apiBase: storage.get("apiBase", ""),
        apiOnline: false,
        bots: storage.get("bots", []),
        projects: storage.get("projects", []),
        wallet: {
          connected: false,
          address: null,
          chainId: null,
        },
        autopay: storage.get("autopay", false),
        settings: storage.get("settings", {
          routing: "Auto",
          quantum: "Q-Flux",
          threshold: "",
        }),
        lockdown: storage.get("lockdown", false),
      };

      const apiBaseInput = document.getElementById("api-base");
      const apiStatus = document.getElementById("api-status");
      const walletStatus = document.getElementById("wallet-status");
      const networkStatus = document.getElementById("network-status");
      const botList = document.getElementById("bot-list");
      const projectList = document.getElementById("project-list");
      const autopayStatus = document.getElementById("autopay-status");
      const actionFeedback = document.getElementById("action-feedback");
      const terminalLog = document.getElementById("terminal-log");
      const terminalClock = document.getElementById("terminal-clock");
      const metricTotalBalance = document.getElementById("metric-total-balance");
      const metricAvailableBalance = document.getElementById("metric-available-balance");
      const metricLockedBalance = document.getElementById("metric-locked-balance");
      const metricActiveAgents = document.getElementById("metric-active-agents");
      const sendStatus = document.getElementById("send-status");
      const botStatus = document.getElementById("bot-status");
      const projectStatus = document.getElementById("project-status");
      const activityStatus = document.getElementById("activity-status");
      const metricPreferredNode = document.getElementById("metric-preferred-node");
      const lastTransaction = document.getElementById("last-transaction");
      const pendingOps = document.getElementById("pending-ops");
      const metricNetworkLatency = document.getElementById("metric-network-latency");
      const metricNetworkPeers = document.getElementById("metric-network-peers");
      const metricNetworkBandwidth = document.getElementById("metric-network-bandwidth");
      const metricSyncHeight = document.getElementById("metric-sync-height");
      const metricSyncProgress = document.getElementById("metric-sync-progress");
      const metricSyncEta = document.getElementById("metric-sync-eta");
      const metricMiningPerformance = document.getElementById("metric-mining-performance");
      const metricMiningCores = document.getElementById("metric-mining-cores");
      const metricMiningEfficiency = document.getElementById("metric-mining-efficiency");
      const routingSelect = document.getElementById("routing");
      const quantumSelect = document.getElementById("quantum");
      const thresholdInput = document.getElementById("threshold");
      const lockdownStatus = document.getElementById("lockdown-status");
      const tabButtons = document.querySelectorAll(".tab-button");
      const tabContents = document.querySelectorAll(".tab-content");
      const fullscreenToggle = document.getElementById("fullscreen-toggle");
      const fullscreenStatus = document.getElementById("fullscreen-status");

      const formatAddress = (address) => (address ? `${address.slice(0, 6)}...${address.slice(-4)}` : "—");
      const formatBtc = (value) =>
        `₿ ${new Intl.NumberFormat("es-ES", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value ?? 0)}`;
      const formatCount = (value) => new Intl.NumberFormat("es-ES").format(value ?? 0);

      const setStatus = (element, status, message) => {
        if (!element) {
          return;
        }
        element.textContent = message ?? "";
        element.classList.remove("is-loading", "is-success", "is-error");
        if (status) {
          element.classList.add(`is-${status}`);
        }
      };

      const sanitizeAddressInput = (value) => value.replace(/\s+/g, "");

      const isValidAddress = (value) => {
        if (!value) {
          return false;
        }
        const normalized = value.trim();
        const ethRegex = /^0x[a-fA-F0-9]{40}$/;
        const satRegex = /^sat:\/\/[a-zA-Z0-9/_-]+$/;
        return ethRegex.test(normalized) || satRegex.test(normalized);
      };

      const parseAmount = (value) => {
        const normalized = value.replace(",", ".");
        const parsed = Number.parseFloat(normalized);
        if (Number.isNaN(parsed) || parsed <= 0) {
          return null;
        }
        return parsed;
      };

      const updateInfra = () => {
        if (!state.apiBase) {
          apiStatus.textContent = "Sin configurar";
        } else {
          apiStatus.textContent = state.apiOnline ? "En línea" : "Offline";
        }
        walletStatus.textContent = state.wallet.connected ? formatAddress(state.wallet.address) : "No conectada";
        networkStatus.textContent = state.wallet.chainId ? state.wallet.chainId : "Desconocida";
        autopayStatus.textContent = state.autopay ? "Auto-pago: activo" : "Auto-pago: apagado";
      };

      const updateFullscreenUI = (supported) => {
        if (!fullscreenToggle || !fullscreenStatus) {
          return;
        }
        if (!supported) {
          fullscreenToggle.disabled = true;
          fullscreenToggle.textContent = "Pantalla completa no disponible";
          fullscreenToggle.setAttribute("aria-pressed", "false");
          fullscreenStatus.textContent = "Pantalla completa: no soportada";
          fullscreenStatus.className = "status-pill warn";
          return;
        }
        const isActive = Boolean(document.fullscreenElement);
        fullscreenToggle.disabled = false;
        fullscreenToggle.textContent = isActive
          ? "Salir de pantalla completa"
          : "Entrar en modo pantalla completa";
        fullscreenToggle.setAttribute("aria-pressed", String(isActive));
        fullscreenStatus.textContent = isActive ? "Pantalla completa: activa" : "Pantalla completa: inactiva";
        fullscreenStatus.className = `status-pill ${isActive ? "success" : "neutral"}`;
      };

      const setOfflineMetrics = () => {
        const offlineValue = "Offline";
        if (metricTotalBalance) {
          metricTotalBalance.textContent = offlineValue;
        }
        if (metricAvailableBalance) {
          metricAvailableBalance.textContent = offlineValue;
        }
        if (metricLockedBalance) {
          metricLockedBalance.textContent = offlineValue;
        }
        if (metricActiveAgents) {
          metricActiveAgents.textContent = offlineValue;
        }
        if (metricPreferredNode) {
          metricPreferredNode.textContent = offlineValue;
        }
        if (lastTransaction) {
          lastTransaction.textContent = offlineValue;
        }
        if (pendingOps) {
          pendingOps.textContent = offlineValue;
        }
        if (metricNetworkLatency) {
          metricNetworkLatency.textContent = offlineValue;
        }
        if (metricNetworkPeers) {
          metricNetworkPeers.textContent = offlineValue;
        }
        if (metricNetworkBandwidth) {
          metricNetworkBandwidth.textContent = offlineValue;
        }
        if (metricSyncHeight) {
          metricSyncHeight.textContent = offlineValue;
        }
        if (metricSyncProgress) {
          metricSyncProgress.textContent = offlineValue;
        }
        if (metricSyncEta) {
          metricSyncEta.textContent = offlineValue;
        }
        if (metricMiningPerformance) {
          metricMiningPerformance.textContent = offlineValue;
        }
        if (metricMiningCores) {
          metricMiningCores.textContent = offlineValue;
        }
        if (metricMiningEfficiency) {
          metricMiningEfficiency.textContent = offlineValue;
        }
      };

      const setSensitiveActionsState = (enabled) => {
        document.querySelectorAll("[data-requires-api='true']").forEach((button) => {
          button.disabled = !enabled;
        });
      };

      const ensureApiOnline = (actionLabel) => {
        if (!state.apiBase) {
          setFeedback(`API sin configurar. ${actionLabel} bloqueada en modo offline.`, "warn");
          return false;
        }
        if (!state.apiOnline) {
          setFeedback(`API offline. ${actionLabel} bloqueada hasta recuperar conexión.`, "warn");
          return false;
        }
        return true;
      };

      const applyMetrics = (metrics) => {
        if (!metrics) {
          return;
        }
        if (metricTotalBalance) {
          metricTotalBalance.textContent = formatBtc(metrics.total_balance_btc);
        }
        if (metricAvailableBalance) {
          metricAvailableBalance.textContent = formatBtc(metrics.available_balance_btc);
        }
        if (metricLockedBalance) {
          metricLockedBalance.textContent = formatBtc(metrics.locked_balance_btc);
        }
        if (metricActiveAgents) {
          metricActiveAgents.textContent = formatCount(metrics.active_agents ?? metrics.ai_unlocked_agents);
        }
        if (metricPreferredNode) {
          metricPreferredNode.textContent = metrics.preferred_node ?? "—";
        }
        if (lastTransaction) {
          lastTransaction.textContent = metrics.last_transaction ?? "—";
        }
        if (pendingOps) {
          pendingOps.textContent = formatCount(metrics.pending_ops);
        }
      };

      const applyNetworkMetrics = (network) => {
        if (!network) {
          return;
        }
        if (metricNetworkLatency) {
          metricNetworkLatency.textContent = network.latency_ms ? `${network.latency_ms} ms` : "—";
        }
        if (metricNetworkPeers) {
          metricNetworkPeers.textContent = formatCount(network.peers);
        }
        if (metricNetworkBandwidth) {
          metricNetworkBandwidth.textContent = network.bandwidth_gbps ? `${network.bandwidth_gbps} Gbps` : "—";
        }
        if (metricSyncHeight) {
          metricSyncHeight.textContent = formatCount(network.block_height);
        }
        if (metricSyncProgress) {
          metricSyncProgress.textContent = network.sync_progress ? `${network.sync_progress}%` : "—";
        }
        if (metricSyncEta) {
          metricSyncEta.textContent = network.sync_eta ?? "—";
        }
      };

      const applyMiningMetrics = (mining) => {
        if (!mining) {
          return;
        }
        if (metricMiningPerformance) {
          metricMiningPerformance.textContent = mining.performance_ths ? `${mining.performance_ths} TH/s` : "—";
        }
        if (metricMiningCores) {
          metricMiningCores.textContent = formatCount(mining.active_cores);
        }
        if (metricMiningEfficiency) {
          metricMiningEfficiency.textContent = mining.efficiency ? `${mining.efficiency}%` : "—";
        }
      };

      const updateSecurityStatus = () => {
        if (!lockdownStatus) {
          return;
        }
        lockdownStatus.textContent = state.lockdown ? "Lockdown: activo" : "Lockdown: inactivo";
        lockdownStatus.classList.toggle("warn", state.lockdown);
      };

      const setFeedback = (message, tone = "info") => {
        if (!actionFeedback) {
          return;
        }
        actionFeedback.textContent = message;
        actionFeedback.classList.remove("success", "warn");
        if (tone === "success") {
          actionFeedback.classList.add("success");
        }
        if (tone === "warn") {
          actionFeedback.classList.add("warn");
        }
      };

      let terminalLedger = [];

      const loadTerminalLedger = async () => {
        if (!state.apiBase) {
          terminalLedger = [];
          return;
        }
        try {
          const data = await apiRequest("/terminal/ledger");
          if (Array.isArray(data)) {
            terminalLedger = data;
          } else if (Array.isArray(data?.agents)) {
            terminalLedger = data.agents;
          } else {
            terminalLedger = [];
          }
        } catch (error) {
          terminalLedger = [];
        }
      };

      const setOfflineNetworkMetrics = () => {
        const offlineValue = "Offline";
        if (metricNetworkLatency) {
          metricNetworkLatency.textContent = offlineValue;
        }
        if (metricNetworkPeers) {
          metricNetworkPeers.textContent = offlineValue;
        }
        if (metricNetworkBandwidth) {
          metricNetworkBandwidth.textContent = offlineValue;
        }
        if (metricSyncHeight) {
          metricSyncHeight.textContent = offlineValue;
        }
        if (metricSyncProgress) {
          metricSyncProgress.textContent = offlineValue;
        }
        if (metricSyncEta) {
          metricSyncEta.textContent = offlineValue;
        }
      };

      const setOfflineMiningMetrics = () => {
        const offlineValue = "Offline";
        if (metricMiningPerformance) {
          metricMiningPerformance.textContent = offlineValue;
        }
        if (metricMiningCores) {
          metricMiningCores.textContent = offlineValue;
        }
        if (metricMiningEfficiency) {
          metricMiningEfficiency.textContent = offlineValue;
        }
      };

      const loadMetrics = async () => {
        if (!state.apiBase) {
          state.apiOnline = false;
          setOfflineMetrics();
          setSensitiveActionsState(false);
          updateInfra();
          return;
        }
        try {
          const metrics = await apiRequest("/metrics");
          state.apiOnline = true;
          applyMetrics(metrics);
          setSensitiveActionsState(true);
        } catch (error) {
          state.apiOnline = false;
          setOfflineMetrics();
          setSensitiveActionsState(false);
        }
        updateInfra();
      };

      const loadNetworkMetrics = async () => {
        if (!state.apiBase) {
          setOfflineNetworkMetrics();
          return;
        }
        try {
          const network = await apiRequest("/network");
          applyNetworkMetrics(network);
        } catch (error) {
          setOfflineNetworkMetrics();
        }
      };

      const loadMiningMetrics = async () => {
        if (!state.apiBase) {
          setOfflineMiningMetrics();
          return;
        }
        try {
          const mining = await apiRequest("/mining");
          applyMiningMetrics(mining);
        } catch (error) {
          setOfflineMiningMetrics();
        }
      };

      const refreshDashboard = async () => {
        await loadMetrics();
        await loadNetworkMetrics();
        await loadMiningMetrics();
        await loadLedgerSnapshot();
        await loadTerminalLedger();
        updateTerminal();
      };

      const renderTerminalLine = () => {
        const time = new Date().toLocaleTimeString("es-ES", { hour12: false });
        if (!terminalLedger.length) {
          return `
            <div class="terminal-line">
              <span>[${time}]</span>
              <span>•</span>
              <span>Terminal offline</span>
              <span>•</span>
              <span>Conecta la API para ver el ledger.</span>
            </div>
          `;
        }
        const entry = terminalLedger[Math.floor(Math.random() * terminalLedger.length)];
        const botId = String(entry?.id ?? 0).padStart(3, "0");
        const expertise = entry?.expertise ?? "investigación distribuida";
        const networks = entry?.neural_networks ?? 0;
        const progress = entry?.progress ?? 0;
        return `
          <div class="terminal-line">
            <span>[${time}]</span>
            <span>•</span>
            <span>Bot #${botId}</span>
            <span>•</span>
            <span>Especialista en ${expertise}</span>
            <span>•</span>
            <span>NN:${networks}</span>
            <span>•</span>
            <span>Progreso: ${progress}%</span>
          </div>
        `;
      };

      const updateTerminal = () => {
        if (!terminalLog) {
          return;
        }
        const lineCount = terminalLedger.length ? 10 : 1;
        const lines = Array.from({ length: lineCount }, renderTerminalLine).join("");
        terminalLog.innerHTML = lines;
        terminalClock.textContent = new Date().toLocaleTimeString("es-ES", { hour12: false });
      };

      const renderBots = () => {
        botList.innerHTML = "";
        if (!state.bots.length) {
          botList.innerHTML = "<p class='helper-text'>Sin bots activos. Despliega uno para comenzar.</p>";
          return;
        }
        state.bots.forEach((bot) => {
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `
            <h3>${bot.task}</h3>
            <div class="stat-row"><span class="stat-label">Presupuesto</span><span class="stat-value">₿ ${bot.budget}</span></div>
            <div class="stat-row"><span class="stat-label">Especialidad</span><span class="stat-value">${bot.specialty ?? "Operaciones urbanas"}</span></div>
            <div class="stat-row"><span class="stat-label">Estado</span><span class="status-pill ${bot.statusClass}">${bot.status}</span></div>
            <div class="stat-row"><span class="stat-label">Responsable</span><span class="stat-value">${bot.owner}</span></div>
          `;
          botList.appendChild(item);
        });
      };

      const renderProjects = () => {
        projectList.innerHTML = "";
        if (!state.projects.length) {
          projectList.innerHTML = "<p class='helper-text'>Aún no hay proyectos publicados.</p>";
          return;
        }
        state.projects.forEach((project) => {
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `
            <h3>${project.name}</h3>
            <p class="helper-text">${project.description}</p>
            <div class="stat-row"><span class="stat-label">Autor</span><span class="stat-value">${project.owner}</span></div>
            <div class="stat-row"><span class="stat-label">Estado</span><span class="status-pill neutral">${project.status}</span></div>
          `;
          projectList.appendChild(item);
        });
      };

      const persist = () => {
        storage.set("apiBase", state.apiBase);
        storage.set("bots", state.bots);
        storage.set("projects", state.projects);
        storage.set("autopay", state.autopay);
        storage.set("settings", state.settings);
        storage.set("lockdown", state.lockdown);
      };

      const apiRequest = async (path, options = {}) => {
        if (!state.apiBase) {
          return null;
        }
 codex/document-api-endpoints-and-error-handling
        const response = await fetch(`${state.apiBase}${path}`, {
          headers: {
            "Content-Type": "application/json",
          },
          ...options,
        });
        if (!response.ok) {
          const message = await response.text();
          throw new Error(message || "API error");

        try {
          const response = await fetch(`${state.apiBase}${path}`, {
            headers: {
              "Content-Type": "application/json",
            },
            ...options,
          });
          if (!response.ok) {
            throw new Error("API error");
          }
          const data = await response.json();
          state.apiOnline = true;
          updateInfra();
          return data;
        } catch (error) {
          state.apiOnline = false;
          updateInfra();
          throw error;
 main
        }
      };

      const requestWithStatus = async (element, path, options, labels) => {
        if (!state.apiBase) {
          setStatus(element, "error", labels?.missing ?? "Define una API base primero.");
          return null;
        }
        setStatus(element, "loading", labels?.loading ?? "Conectando con la API...");
        try {
          const result = await apiRequest(path, options);
          setStatus(element, "success", labels?.success ?? "Respuesta recibida.");
          return result;
        } catch (error) {
          const detail = error?.message ? ` ${error.message}` : "";
          setStatus(element, "error", `${labels?.error ?? "Error en la API."}${detail}`);
          return null;
        }
      };

      const handleConnectWallet = async () => {
        if (!window.ethereum) {
          setStatus(sendStatus, "error", "Wallet Web3 no detectada. Instala MetaMask o un proveedor compatible.");
          return;
        }
        setStatus(sendStatus, "loading", "Conectando wallet...");
        try {
          const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
          state.wallet.connected = true;
          state.wallet.address = accounts[0];
          state.wallet.chainId = await window.ethereum.request({ method: "eth_chainId" });
          updateInfra();
          setStatus(sendStatus, "success", "Wallet conectada.");
        } catch (error) {
          setStatus(sendStatus, "error", "No se pudo conectar la wallet.");
        }
      };

      const handleSend = async () => {
        const toInput = document.getElementById("send-to");
        const amountInput = document.getElementById("send-amount");
        const to = sanitizeAddressInput(toInput.value.trim());
        const amountRaw = amountInput.value.trim();
        const amount = parseAmount(amountRaw);
        toInput.value = to;
        if (!to || !amountRaw) {
          setStatus(sendStatus, "error", "Completa la dirección y la cantidad.");
          return;
        }
        if (!isValidAddress(to)) {
          setStatus(sendStatus, "error", "Dirección inválida. Usa formato 0x... o sat://");
          return;
        }
        if (!amount) {
          setStatus(sendStatus, "error", "Cantidad inválida. Usa un valor mayor a 0.");
          return;
        }
        if (!state.wallet.connected) {
          setStatus(sendStatus, "error", "Conecta la wallet primero.");
          return;
        }
        if (!window.ethereum) {
          setStatus(sendStatus, "error", "Wallet Web3 no detectada.");
          return;
        }
        setStatus(sendStatus, "loading", "Enviando transacción...");
        const value = `0x${Math.floor(amount * 1e18).toString(16)}`;
        try {
          await window.ethereum.request({
            method: "eth_sendTransaction",
            params: [
              {
                from: state.wallet.address,
                to,
                value,
              },
            ],
          });
          setStatus(sendStatus, "success", "Transacción enviada.");
        } catch (error) {
          setStatus(sendStatus, "error", "No se pudo enviar la transacción.");
        }
      };

      const handleReceive = async () => {
        if (!state.wallet.connected && !state.apiBase) {
          setFeedback("Define una API o conecta la wallet para generar una dirección de recepción.", "warn");
          return;
        }
        let receiveAddress = state.wallet.address;
        if (state.apiBase) {
          try {
            const apiResult = await apiRequest("/wallet/receive", {
              method: "POST",
              body: JSON.stringify({ address: state.wallet.address }),
            });
            if (apiResult?.address) {
              receiveAddress = apiResult.address;
            }
          } catch (error) {
            setFeedback("No se pudo generar la dirección en la API.", "warn");
            return;
          }
        }
        if (!receiveAddress) {
          setFeedback("Conecta la wallet para generar una dirección real.", "warn");
          return;
        }
        setFeedback(`Recepción lista: ${receiveAddress}`, "success");
      };

      const handleActivity = async () => {
        if (!ensureApiOnline("Actividad")) {
          return;
        }
        try {
          const apiResult = await apiRequest("/activity");
          if (apiResult && lastTransaction && pendingOps) {
            lastTransaction.textContent = apiResult.last_activity ?? "—";
            pendingOps.textContent = formatCount(apiResult.pending);
          }
          setFeedback("Actividad actualizada con los últimos movimientos.", "success");
        } catch (error) {
          setFeedback("No se pudo cargar actividad desde la API.", "warn");
        }
      };

      const handleSaveSettings = async () => {
        if (!ensureApiOnline("Configuración avanzada")) {
          return;
        }
        const routing = routingSelect?.value ?? "Auto";
        const quantum = quantumSelect?.value ?? "Q-Flux";
        const threshold = thresholdInput?.value.trim() ?? "";
        if (threshold && Number(threshold) <= 0) {
          setFeedback("El umbral debe ser un número positivo.", "warn");
          return;
        }
        state.settings = { routing, quantum, threshold };
        persist();
        try {
          await apiRequest("/settings", {
            method: "POST",
            body: JSON.stringify(state.settings),
          });
        } catch (error) {
          setFeedback("No se pudo guardar la configuración en la API.", "warn");
          return;
        }
        setFeedback("Configuración avanzada guardada.", "success");
      };

      const handleExport = async () => {
        if (!ensureApiOnline("Exportación")) {
          return;
        }
        const payload = {
          exportedAt: new Date().toISOString(),
          apiBase: state.apiBase,
          wallet: state.wallet,
          bots: state.bots,
          projects: state.projects,
          settings: state.settings,
          lockdown: state.lockdown,
        };
        try {
          await apiRequest("/export", {
            method: "POST",
            body: JSON.stringify(payload),
          });
        } catch (error) {
          setFeedback("No se pudo exportar en la API.", "warn");
          return;
        }
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "satoshi-world-export.json";
        link.click();
        URL.revokeObjectURL(url);
        setFeedback("Exportación lista. Archivo descargado.", "success");
      };

      const handleLockdown = async () => {
        if (!ensureApiOnline("Lockdown")) {
          return;
        }
        if (state.lockdown) {
          setFeedback("El lockdown ya está activo en este panel.", "warn");
          return;
        }
        const confirmLockdown = window.confirm("¿Quieres activar el lockdown total de seguridad?");
        if (!confirmLockdown) {
          return;
        }
        state.lockdown = true;
        persist();
        updateSecurityStatus();
        try {
          await apiRequest("/security/lockdown", { method: "POST" });
        } catch (error) {
          setFeedback("Lockdown activado localmente, pero falló en la API.", "warn");
          return;
        }
        setFeedback("Lockdown activado. Protocolos de seguridad reforzados.", "success");
      };

      const handleDeployBot = async () => {
        if (!ensureApiOnline("Despliegue de bots")) {
          return;
        }
        const task = document.getElementById("bot-task").value.trim();
        const budgetRaw = document.getElementById("bot-budget").value.trim();
        const budget = parseAmount(budgetRaw);
        if (!task || !budgetRaw) {
          setStatus(botStatus, "error", "Completa tarea y presupuesto.");
          return;
        }
        if (!budget) {
          setStatus(botStatus, "error", "Presupuesto inválido. Usa un valor mayor a 0.");
          return;
        }
        const owner = state.wallet.connected ? formatAddress(state.wallet.address) : "Comunidad";
        const payload = {
          task,
          budget: budget.toFixed(2),
          owner,
        };
        let apiResult = null;
        if (state.apiBase) {
          apiResult = await requestWithStatus(
            botStatus,
            "/bots",
            {
              method: "POST",
              body: JSON.stringify(payload),
            },
            {
              loading: "Registrando bot...",
              success: "Bot registrado.",
              error: "No se pudo registrar el bot en la API.",
            },
          );
        }
        if (apiResult) {
          state.bots = apiResult.bots ?? state.bots;
        } else {
          state.bots.unshift({
            task,
            budget: budget.toFixed(2),
            owner,
            status: state.autopay ? "Auto-pago activo" : "En cola",
            statusClass: state.autopay ? "neutral" : "warn",
          });
 codex/document-api-endpoints-and-error-handling
          setStatus(botStatus, "success", "Bot registrado localmente.");

          if (apiResult) {
            state.bots = apiResult.bots ?? state.bots;
          }
        } catch (error) {
          alert("No se pudo registrar el bot en la API.");
          return;
 main
        }
        persist();
        renderBots();
      };

      const handlePublishProject = async () => {
        if (!ensureApiOnline("Publicación de proyectos")) {
          return;
        }
        const name = document.getElementById("project-name").value.trim();
        const description = document.getElementById("project-desc").value.trim();
        const code = document.getElementById("project-code").value.trim();
        if (!name || !description) {
          setStatus(projectStatus, "error", "Completa nombre y descripción.");
          return;
        }
        const owner = state.wallet.connected ? formatAddress(state.wallet.address) : "Ciudadano";
        const payload = { name, description, code, owner };
        let apiResult = null;
        if (state.apiBase) {
          apiResult = await requestWithStatus(
            projectStatus,
            "/projects",
            {
              method: "POST",
              body: JSON.stringify(payload),
            },
            {
              loading: "Publicando proyecto...",
              success: "Proyecto enviado a revisión.",
              error: "No se pudo publicar el proyecto en la API.",
            },
          );
        }
        if (apiResult) {
          state.projects = apiResult.projects ?? state.projects;
        } else {
          state.projects.unshift({
            name,
            description,
            owner,
            status: "Revisión comunitaria",
          });
 codex/document-api-endpoints-and-error-handling
          setStatus(projectStatus, "success", "Proyecto guardado localmente.");

          if (apiResult) {
            state.projects = apiResult.projects ?? state.projects;
          }
        } catch (error) {
          alert("No se pudo publicar el proyecto en la API.");
          return;
 main
        }
        persist();
        renderProjects();
      };

      const handleReceive = async () => {
        const apiResult = await requestWithStatus(
          sendStatus,
          "/wallet/receive",
          { method: "POST" },
          {
            loading: "Generando recepción...",
            success: "Dirección de recepción generada.",
            error: "No se pudo generar la dirección de recepción.",
            missing: "Configura una API base para generar la recepción.",
          },
        );
        if (apiResult?.address) {
          const input = document.getElementById("send-to");
          input.value = apiResult.address;
        }
      };

      const handleActivity = async () => {
        await requestWithStatus(
          activityStatus,
          "/activity",
          { method: "GET" },
          {
            loading: "Cargando actividad...",
            success: "Actividad actualizada.",
            error: "No se pudo cargar la actividad.",
            missing: "Configura una API base para ver la actividad.",
          },
        );
      };

      const handleAutoPay = () => {
        if (!ensureApiOnline("Auto-pago")) {
          return;
        }
        state.autopay = !state.autopay;
        persist();
        updateInfra();
      };

      const applyLedgerSnapshot = (snapshot) => {
        if (!snapshot || !Array.isArray(snapshot.agents)) {
          return;
        }
        state.bots = snapshot.agents.map((agent) => {
          const balance = Number(agent.balance_btc_mirror ?? 0);
          const active = Boolean(agent.ai_unlocked);
          return {
            task: agent.name ?? agent.id ?? "Bot operativo",
            budget: formatBtc(balance).replace("₿ ", ""),
            owner: agent.owner ?? "Ledger",
            status: agent.status ?? (active ? "Activo" : "En espera"),
            statusClass: active ? "" : "warn",
            specialty: agent.specialty ?? agent.description ?? "Operaciones urbanas",
          };
        });
        const metrics = snapshot.metrics ?? {};
        if (metricTotalBalance) {
          metricTotalBalance.textContent = formatBtc(metrics.total_balance_btc);
        }
        if (metricAvailableBalance) {
          metricAvailableBalance.textContent = formatBtc(metrics.available_balance_btc);
        }
        if (metricLockedBalance) {
          metricLockedBalance.textContent = formatBtc(metrics.locked_balance_btc);
        }
        if (metricActiveAgents) {
          metricActiveAgents.textContent = formatCount(metrics.ai_unlocked_agents);
        }
        persist();
        renderBots();
      };

      const loadLedgerSnapshot = async () => {
        if (!state.apiBase) {
          return;
        }
        try {
          const snapshot = await apiRequest("/ledger/snapshot");
          applyLedgerSnapshot(snapshot);
        } catch (error) {
          // Snapshot is optional.
        }
      };

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          tabButtons.forEach((item) => {
            item.classList.remove("active");
            item.setAttribute("aria-selected", "false");
          });
          tabContents.forEach((content) => content.classList.remove("active"));
          button.classList.add("active");
          button.setAttribute("aria-selected", "true");
          const content = document.getElementById(`tab-${button.dataset.tab}`);
          if (content) {
            content.classList.add("active");
          }
        });
      });

      apiBaseInput.value = state.apiBase;
      if (routingSelect) {
        routingSelect.value = state.settings.routing;
      }
      if (quantumSelect) {
        quantumSelect.value = state.settings.quantum;
      }
      if (thresholdInput) {
        thresholdInput.value = state.settings.threshold;
      }
      apiBaseInput.addEventListener("input", (event) => {
        state.apiBase = event.target.value.trim();
        persist();
        updateInfra();
        refreshDashboard();
      });

      document.querySelectorAll("button[data-action]").forEach((button) => {
        button.addEventListener("click", async () => {
          const action = button.dataset.action;
          if (button.dataset.requiresApi === "true") {
            const actionLabel = {
              activity: "Actividad",
              "deploy-bot": "Despliegue de bots",
              "toggle-autopay": "Auto-pago",
              "save-settings": "Configuración avanzada",
              export: "Exportación",
              lockdown: "Lockdown",
              "publish-project": "Publicación de proyectos",
              sync: "Sincronización",
              mine: "Minería",
              optimize: "Optimización",
            }[action] ?? "Acción";
            if (!ensureApiOnline(actionLabel)) {
              return;
            }
          }
          if (action === "connect-wallet") {
            await handleConnectWallet();
          }
          if (action === "send") {
            await handleSend();
          }
          if (action === "receive") {
            await handleReceive();
          }
          if (action === "activity") {
            await handleActivity();
          }
          if (action === "deploy-bot") {
            await handleDeployBot();
          }
          if (action === "publish-project") {
            await handlePublishProject();
          }
          if (action === "toggle-autopay") {
            handleAutoPay();
          }
 codex/document-api-endpoints-and-error-handling
          if (action === "receive") {
            handleReceive();
          }
          if (action === "activity") {
            handleActivity();

          if (action === "save-settings") {
            await handleSaveSettings();
          }
          if (action === "export") {
            await handleExport();
          }
          if (action === "lockdown") {
            await handleLockdown();
 main
          }
        });
      });

      if (fullscreenToggle) {
        const fullscreenSupported = Boolean(document.documentElement.requestFullscreen);
        updateFullscreenUI(fullscreenSupported);
        fullscreenToggle.addEventListener("click", async () => {
          if (!fullscreenSupported) {
            alert("Tu navegador no soporta la API de pantalla completa.");
            return;
          }
          try {
            if (document.fullscreenElement) {
              await document.exitFullscreen();
            } else {
              await document.documentElement.requestFullscreen();
            }
          } catch (error) {
            alert("No se pudo cambiar al modo de pantalla completa.");
          }
        });
        document.addEventListener("fullscreenchange", () => updateFullscreenUI(fullscreenSupported));
        document.addEventListener("fullscreenerror", () => updateFullscreenUI(fullscreenSupported));
      }

      if (window.ethereum) {
        window.ethereum.on("accountsChanged", (accounts) => {
          state.wallet.address = accounts[0] ?? null;
          state.wallet.connected = Boolean(state.wallet.address);
          updateInfra();
        });
        window.ethereum.on("chainChanged", (chainId) => {
          state.wallet.chainId = chainId;
          updateInfra();
        });
      }

      updateInfra();
      updateSecurityStatus();
      renderBots();
      renderProjects();
 codex/document-api-endpoints-and-error-handling
      updateTerminal();
      loadLedgerSnapshot();
      loadTerminalLedger().then(() => {
        updateTerminal();
        setInterval(updateTerminal, 3500);
      });

      refreshDashboard();
      setInterval(updateTerminal, 3500);
      setInterval(refreshDashboard, 30000);
 main
    </script>
  </body>
</html>
